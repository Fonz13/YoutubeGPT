0.06 5.219 hey how the hell do you protect your API 
3.06 4.02 routes I'm not sure to make sure I don't 
5.279 3.78 leak vulnerable information to make sure 
7.08 3.479 the endpoints don't get spammed to make 
9.059 3.66 sure everything goes right and they are 
10.559 4.381 properly secured I always take five 
12.719 5.101 steps and here they are step number one 
14.94 4.8 is by far the easiest and nowadays you 
17.82 4.08 barely have to worry about it except you 
19.74 4.92 do everything yourself but that is use 
21.9 5.219 https make sure the connection between 
24.66 4.26 client and server is encrypted so nobody 
27.119 3.721 can do a man in the middle attack and 
28.92 3.78 read your data that is passed from the 
30.84 3.48 client to the server and Back Again 
32.7 3.9 nowadays you don't really have to think 
34.32 4.68 about it it's mostly done automatically 
36.6 4.86 for you number two is really important 
39.0 3.96 it's authentication and authorization 
41.46 4.14 those are two different things 
42.96 4.919 authentication means ensuring the user 
45.6 5.04 is who they claim to be either through 
47.879 4.801 or through Google or through GitHub or 
50.64 3.96 through a password authentication with 
52.68 3.96 email and password you know and in 
54.6 4.32 return for those credentials the user 
56.64 4.919 gets a token that is either a Json web 
58.92 4.619 token or it can be a session token that 
61.559 3.6 you also store in a database those are 
63.539 3.181 the two different approaches to 
65.159 3.841 authentication now the important thing 
66.72 4.92 is whenever that user makes a request to 
69.0 4.92 your API that HTTP only cookie meaning 
71.64 4.08 it can't be changed by JavaScript or red 
73.92 3.84 but JavaScript is going to be 
75.72 4.2 automatically sent along in the request 
77.76 4.2 to your server and then either you 
79.92 4.739 validate the signature of the Json web 
81.96 4.92 token in your API route or you go ahead 
84.659 3.96 and fetch that session cookie in the 
86.88 3.72 database and see if that is a valid 
88.619 4.561 session and that is the authentication 
90.6 4.979 part done now you know the user is who 
93.18 4.38 they claim to be for example their email 
95.579 4.441 and then authorization is the question 
97.56 4.8 of well we now know who the user is but 
100.02 4.08 what are they allowed to do if we have 
102.36 4.38 something like role-based authentication 
104.1 5.58 are they an admin are they a user or if 
106.74 4.739 we don't have that well what is any user 
109.68 4.38 allowed to do are they allowed to change 
111.479 4.381 their name in the database how can they 
114.06 4.5 interact with the database that is what 
115.86 4.98 authorization is about so usually what 
118.56 4.379 you do is logical checks you before you 
120.84 4.379 perform a certain action that is linked 
122.939 4.741 to an API endpoint like for example the 
125.219 4.441 goal of one API endpoint is to change a 
127.68 3.96 username in a database before doing that 
129.66 3.96 in regards of authorization an example 
131.64 4.02 would be has the user changed their 
133.62 4.32 username more than three times in the 
135.66 3.96 past hour and if they did well then they 
137.94 4.08 are not authorized to do that same 
139.62 4.259 action in the same hour again okay so 
142.02 3.84 now we're sending encrypted data traffic 
143.879 4.201 know who the user is and what they're 
145.86 4.32 allowed to do but anyone even without 
148.08 4.44 being logged in could totally spam your 
150.18 4.26 API endpoint and force you to make so 
152.52 4.68 many requests back and forth to your 
154.44 5.34 database costing you money so step 
157.2 4.92 number three is rate limit your API 
159.78 4.739 endpoints don't allow anybody to spam 
162.12 4.68 the hell out of them rate limit them for 
164.519 4.201 example what I usually do is use upstash 
166.8 3.96 for this just full disclosure I am 
168.72 4.379 sponsored by upstash but I used them 
170.76 3.96 before they sponsored me I use them in 
173.099 4.021 personal projects that they are not 
174.72 4.019 sponsoring at all they're not public I 
177.12 2.88 just personally use them and that's why 
178.739 3.78 I stand behind their product in the 
180.0 4.08 agree to being sponsored by them so I 
182.519 3.0 think personally upstage makes this 
184.08 3.78 really easy to protect your API 
185.519 5.041 endpoints especially in a serverless 
187.86 4.5 environment for example next JS that is 
190.56 4.02 mainly what up stash is used for if 
192.36 5.04 you're using server full technology like 
194.58 4.56 node.js for example and express there 
197.4 4.199 are packages just for that that rate 
199.14 4.92 limit your API endpoints even easier 
201.599 4.86 than in serverless environments okay now 
204.06 4.38 nobody can spam our API anymore we know 
206.459 3.541 who is trying to make a request and we 
208.44 4.079 know what that person is allowed to do 
210.0 4.319 but we cannot ensure that person is 
212.519 3.901 trying to make a malicious request 
214.319 3.661 because just knowing who the user is 
216.42 3.959 doesn't mean that they're friendly or 
217.98 5.22 not trying to inject something really 
220.379 4.681 harmful into or API rods and that's why 
223.2 4.5 we do the next step and that step is 
225.06 5.16 input validation it is so so so 
227.7 5.22 important you need to validate client 
230.22 5.099 input anyone can make any request to any 
232.92 4.44 of your API rods with any data that they 
235.319 4.321 want so you need to make sure that the 
237.36 4.5 data you get on your server and then 
239.64 3.84 process process in the request is 
241.86 4.379 actually what you expect and not 
243.48 5.46 malicious input and I personally do a 
246.239 4.5 lot of work in the node.js express nexjs 
248.94 3.9 environment so just in the JavaScript 
250.739 3.901 typescript environment and therefore I 
252.84 3.359 like to use schema validation libraries 
254.64 3.42 for this in typescript you can use 
256.199 3.54 something called yup or you could use 
258.06 3.299 something called zot essentially they 
259.739 4.081 allow you to do the same thing you 
261.359 4.261 define a certain schema a type of data 
263.82 4.319 that you're expecting on your back end 
265.62 5.04 that you can then parse against so you 
268.139 4.981 can parse any data no matter what it is 
270.66 4.62 against that schema and if that data 
273.12 4.56 that you're parsing does not match the 
275.28 4.02 schema your server will throw an error 
277.68 4.32 because you cannot handle the request 
279.3 4.619 with data that you're not expecting and 
282.0 3.84 only if the data that is passed into 
283.919 3.421 your API endpoint is of the certain 
285.84 2.82 schema type and by the way in this 
287.34 3.299 schema you can literally Define 
288.66 4.02 everything you can Define you want a 
290.639 4.5 string that is a maximum of 100 
292.68 5.04 characters that matches a certain regex 
295.139 4.321 you can refine that even if you want to 
297.72 3.66 you can make really sure the data that 
299.46 4.14 you're receiving on the server is 
301.38 4.319 precisely what you're getting and if 
303.6 4.14 that parses correctly then you know okay 
305.699 3.901 the data is fine we can actually work 
307.74 3.66 with it all right we've ensured there is 
309.6 4.02 encrypted traffic we know who is making 
311.4 4.5 a request what they're allowed to do and 
313.62 3.78 nobody can spam our API endpoints and we 
315.9 4.68 even know that the data that we're 
317.4 6.239 getting is exactly what we want but what 
320.58 5.76 we haven't done yet is super crucial and 
323.639 5.221 step number five really important error 
326.34 4.38 handling we can never ensure that 
328.86 4.32 everything works smoothly in our API 
330.72 5.64 chances are you're also relying on some 
333.18 5.1 third-party API it's just an API to API 
336.36 4.08 there's a lot of communication there's a 
338.28 4.259 lot of stuff that could go wrong servers 
340.44 4.259 not responding you never know and 
342.539 4.261 therefore you want a very solid error 
344.699 3.84 handling the way you do that at least in 
346.8 3.899 the environment that I'm familiar with 
348.539 4.741 is in a try catch block I think it's the 
350.699 5.041 same in Java where you can try a certain 
353.28 4.5 function and then catch any errors that 
355.74 3.84 should occur and then the secret to good 
357.78 4.38 error handling is sending back the 
359.58 4.38 proper HTTP status codes of what's 
362.16 4.2 happening because then you can check 
363.96 4.739 those on the client display an according 
366.36 4.32 error message to the user like a 400 bed 
368.699 4.201 request or a four or nine there's a 
370.68 3.6 conflict in the naming for example so 
372.9 3.18 you want to make sure you're checking 
374.28 3.66 the error in the catch block if it 
376.08 3.48 matches a certain type for example if 
377.94 3.599 you're using axios then you might check 
379.56 4.38 if it's an axial's error and if it is 
381.539 4.321 then you know the structure of the error 
383.94 4.259 similarly if you're using a certain 
385.86 4.32 schema validation library to validate 
388.199 4.081 the input remember when the parsing 
390.18 3.9 fails there's an error being thrown and 
392.28 4.32 in the catch block you can check if the 
394.08 4.8 error is of that type if it was created 
396.6 4.26 by Zod or by yup and if it turns out the 
398.88 4.02 error is in the shape of a Zod or yup 
400.86 4.26 arrow and caused by them that allows you 
402.9 4.62 to really easily handle how you send 
405.12 5.1 back your HTTP status codes to the 
407.52 4.38 client and then finally if you have no 
410.22 3.9 idea what the error is if it's neither 
411.9 3.96 an axial error or a result error or 
414.12 3.96 whatever tools you're using in your app 
415.86 5.04 then in the worst case you can always 
418.08 4.739 send back a generic 5 100 error message 
420.9 4.56 you know you don't know what's wrong so 
422.819 4.44 just send back an internal server error 
425.46 4.079 and those are my steps to properly 
427.259 4.38 securing your API endpoints if I missed 
429.539 4.44 anything be sure to let me know and also 
431.639 4.921 this video was inspired by a Twitter 
433.979 3.66 post by this user right here and I'm 
436.56 2.759 gonna link them in the description 
437.639 4.021 that's where the inspiration for this 
439.319 4.801 video came from on how to secure your 
441.66 4.74 rest API routes but with my own twist to 
444.12 4.38 it for example the authorization was not 
446.4 3.78 mentioned in that thread at all which I 
448.5 4.139 feel like is really important to 
450.18 4.019 properly secure your API endpoints as 
452.639 3.18 well thanks very much for watching I 
454.199 3.601 really hope you learned something new on 
455.819 3.72 how to properly protect your API 
457.8 5.6 endpoints and then I'm gonna see in the 
459.539 3.861 next video have a good one and bye bye 
